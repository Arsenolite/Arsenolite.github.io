---
title: 记吃到的Kotlin语法糖总结
tags: ["Kotlin","Java"]
categories: ["2018-10"]
date: 2018-10-19 10:44:02
---



最近在着手写一个[TornadoFx](https://tornadofx.io/)的项目，接触了之前从未写过的Kotlin，吃到了大量的语法糖，给我一种“到处充满了Lambda”的既视感。

很多东西一个花括号就能搞定，隐藏了很多“当场实现接口”、“覆写方法”的繁琐语法，确实写起来非常的舒服，写篇文章总结一下。

目前来说，我体会到的主要有这些语法糖：

+ 构造块
替代了构造函数，而Java中的有参构造被移到了类名右边的圆括号内：

```java
//java
public class XXXBo{
    public XXXBo(){
    
    }
    public XXXBo(int i){
    
    }
}

//kotlin
class XXXBo(var i: Int) {
   init{
   
   }
}
```
顺带提一下延迟加载，Kotlin要求显式声明在声明时不赋值的变量：
（读起来可能有点拗口，意思是默认情况下如果变量声明不赋值，是一个编译期错误）
```java
//编译错误：Property must be initialized or be abstract
//var bo:XXXBo;
```
只有加入`lateinit` 关键字才允许之后在其他地方赋值：
```java
lateinit var bo:XXXBo;
```
延迟加载机制能和DI框架很好的配合，虽然Spring的写法是这样的：
```java
var bo:XXXBo by di();
```
需要和延迟加载区分的一个机制是懒加载，代码是这样的：
```java
val bo by lazy{
    XXXBo(param1);
}
```
注意，懒加载用于`val`变量，一个非常对口的应用场景就是单例模式，如果在单例模式中使用lateinit虽然也可以实现，但是会增加不必要的逻辑。


+ 分号省略

代码略；每一行代码的分号可以省略，（不知道编译那边是怎么做的……）

+ 类型推断+使用var来声明变量

这个在类名很长的时候兼职就是拯救世界……

```java
//java
XXXBo bo = new XXXBo();
final XXXBo bo = new XXXBo();
//kotlin
var bo = XXXBo();
val bo = XXXBo();
```

+ 进一步简化的try-with-resource

```java
//java6
try{
    InputStream is = FileInputStream(filename);
}catch(Exception e){
            
}finally{
    is.close();
}
//java7+
try (InputStream is = FileInputStream(filename)) {

}catch(Exception e){
            
}
//kotlin
FileInputStream(filename).use {
    //使用it对象来使用这个流本身
    var properties:Properties = Properties();
    properties.load(it)
}
```
这个`use()`方法本质是调用`close()`方法，见[这个回答](https://stackoverflow.com/questions/26969800/try-with-resources-in-kotlin)

+ 对NPE进行了最大限度的消除：强制null检查

```java
//java
XXXBo bo = null;
bo.getXXX();//NPE

//kotlin
//编译错误：Null can not be a value of a non-null type XXXBo
//var bo:XXXBo = null;

var bo:XXXBo? = null;

//编译错误：Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type XXXBo
//bo.count;

if(bo !=null){
    bo.count;
}
```
+ 对Get/Set进行最大程度的消除（[数据类](https://www.kotlincn.net/docs/reference/data-classes.html)）：

Java里其实有个叫Lombok的东西干了差不多的事，在编译器自动生成` Getter Setter equals() toString() `这么些方法。
不过Kotlin里调用get/set方法也可以不用方法名，而是直接.属性名。
顺带一提,Kotlin的主方法由于没有static方法，用的是伴生对象，并且方法加入`@JvmStatic`注解。
不过IDEA似乎没法用psvm来快速生成了，也不知道是复杂了还是简单了（

```java
//java
public class XXXBo{
    private Integer id;
    //getter setter
}
psvm{
    new XXXBo().getId();
}
//kotlin
data class XXXBo(val id:Int){

}
companion object {
    @JvmStatic
    fun main(args: Array<String>) {
        XXXBo().id;  
    }
}
```

+ 语言层面的TODO支持：

```java
//java

//TODO xxx
//完全依赖IDE语法高亮，对实际编译的代码来说就是空代码

//kotlin
//标准库提供TODO函数，执行此处代码会抛出一个异常

TODO()

//@kotlin.internal.InlineOnly
//public inline fun TODO(): Nothing = throw NotImplementedError()

```

+ KDoc（对位JavaDoc）支持Markdown语法

详见[链接](https://www.kotlincn.net/docs/reference/kotlin-doc.html)