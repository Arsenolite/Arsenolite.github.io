---
title: 微信小程序支付对接开发笔记
date: 2019-05-20 11:19:03
tags: 
---
新单位新项目，微信小程序对接微信支付+退款，由于开发测试是真的繁琐，在此记录一下笔记。

## 下载微信SDK，编写后端代码

……随便吐槽一下，微信SDK被人挖出来漏洞之后就不放github了，只能从微信官网下载，然后阿里规约扫描报了一大堆错……也没法改，万一后续SDK更新了呢

### 配置类
首先创建一个SDK内`WxPayConfig`类的实现类，由于项目名是微商城，取名叫`WscWxConfig`。

使用`Spring`配置读取的方式，在类里声明`AppId`、`MchId`（商户号），`Key`，证书内容（字节数组）几个成员变量，然后`AppId MchId key`的`getter`直接用`lombok`生成。

`getCertStream`这个方法需要重写为`return new ByteArrayInputStream(this.certData);`的形式，`getWxPayDomain`更麻烦：

```java
IWXPayDomain getWXPayDomain() {
        return new IWXPayDomain() {
            @Override
            public void report(String domain, long elapsedTimeMillis, Exception ex) {

            }
            @Override
            public DomainInfo getDomain(WXPayConfig config) {
                return new DomainInfo(WXPayConstants.DOMAIN_API, true);
            }
        };
    }
```

顺带给`WxPay`类做一个单例，声明一个`WxPay`类型的变量，然后用`@PostConstruct`注解初始化方法：
**注意这里的构造函数传参第三个参数，表示使用沙箱环境**
```java
 public void initWxPay(){
        try {
            this.wxPay = new WXPay(this, false, true);
        } catch (Exception e) {
            log.error("inital wxpay failed ", e);
        }
    }
```
这样配置类就写完了。

### Service
微信SDK给了轻度封装，至少使用`Map<String, String>`就可以完成参数填写了

#### 统一下单
由于负责用户模块的同事的设计是不存储OpenId，因此该方法直接接受code，订单号，金额，公司名（用于微信订单描述）作为参数。
接下来是调用微信SDK发送请求，并且将拿到的prepay_id返回前端。

#### 接受支付通知
幂等性处理后，将接收到的支付信息持久化一份到数据库，并且根据业务结果+支付金额调订单Service。

#### 退款
这回是由商户服务器发起请求，所以不用OpenId了，指定订单号、金额、退款金额、售后单号即可

#### 接受退款通知
类似支付通知的幂等性处理，持久化一份到数据库，并根据业务结果调售后Service。

### Controller
主要是两个接收通知的接口，以及退款接口信息的解密方法。

先从`request.getInputStream()`中获取XML，然后用微信SDK转成Map，再用微信SDK做签名校验。

## 测试

后端码狗自测微信小程序支付接口简直要人命……居然没找到描述全流程的博文
**调个微信支付和玩tmd解谜RPG一样，到处找线索**
因为小程序支付交付需要在沙箱模拟过一遍之后向微信提交验收通过申请，所以直接用沙箱开发。

### 数据准备

#### AppId
小程序所属的公司账号将开发者的微信号加入小程序开发者后，开发者使用微信扫码登录微信小程序后台即可看到。

#### AppSecret
需要超级管理员在小程序后台开发设置生成。

#### MchId
在商户后台将开发者账号加入商户的员工账号后，员工账号会收到包含MchId的通知。


#### Key
商户后台API安全处填写，需要超级管理员验证，需要商户账号开通操作密码
其中沙箱开发要用到SignKey，使用Key请求微信的API生成。

解析退款信息时使用。

#### 证书
商户后台API安全处可以**重设**，最好能找到第一次申请的证书文件。
解析退款信息时使用。

### 内网穿透

本地请求支付的接口需要一个**带https的内网穿透**给`wx.request`用，即使有CI/CD，也懒得改一行代码提一个pr……图省事直接买了NATAPP。

吐槽一下，要调试小程序需要买他的国内隧道+二级域名，15元一年的域名+9元一个月的隧道；

倒是可以选择用自己的域名，但是我域名没备案……而阿里云买的域名要备案需要配阿里云的实例……

还有香港流量包月的隧道，买完才发现这个不能开https……香港流量不包月的倒是可以配自己域名，但是自己域名443端口必须空着，我域名有个开了https的小网盘跑着……

幸好微信的支付通知回调可以不用https，就用免费隧道顶上。

### 统一下单

在微信开发者工具中新建一个小程序，修改AppId为公司小程序的AppId（也可以直接调公司小程序的代码，但是单独测一个支付我还是选择新起一个小程序）。


加一个按钮，测试支付，绑定一个函数，把返回的`requestPayment`用的数据打印出来，顺带请求支付：
```javascript
testPay: function (e) {
    wx.login({
      success(res) {
        if (res.code) {
          // 发起网络请求
          wx.request({
            url: 'https://qxkjwxpay.mynatapp.cc/micro/order/payOrder',
			header: {
              'Authorization': '登录接口生成的JWT内容'
            },
            method: 'POST',
            data: {
              code: res.code,
              amount: '1.01',
              orderNum: '2',
              paymentType: 10
            },
            success(res) {
              console.log(res);
              wx.requestPayment(
                {
                  'timeStamp': res.data.data.timestamp,
                  'nonceStr': res.data.data.nonceStr,
                  'package': res.data.data.prepayId,
                  'signType': 'MD5',
                  'paySign': res.data.data.sign,
                  'success': function (res) { },
                  'fail': function (res) { },
                  'complete': function (res) { }
                })
            }
          })
        } else {
          console.log('登录失败！' + res.errMsg)
        }
      }
    })
  }
```

结果是这样的：
```
code:200
data:{
nonceStr:"klrv5kgx5dJdc7ILG9Uj9k70hUKzXbF8"
prepayId:"prepay_id=wx20190522095426670409"
sign:"A118797887A33C961594D149285EDCEE"
timestamp:1558490065
}
msg:"成功"
subCode:null
```

### 调起支付

果↓然↑啊，扫描开发者工具给的二维码时提示错误：**调用支付JSAPI缺少参数:total_fee**

我寻思统一下单都成功了你在说你吗呢，会报错你就多报几句，是不是把你妈杀了你也只会说缺少total_fee？真的憨批一样

package传的也带了`prepay_id=`，后端生成随机数+签名用的是微信JavaSDK的工具类，签名字段大小写也没问题


发现后端生成签名时，工具类会自动拼上key=AppSecret，而我手动在map里加了一个key……也就是现在的签名内容有问题。。

改掉之后还是报错，看到微信开放社区里[一个帖子](https://developers.weixin.qq.com/community/pay/doc/0006805d6e87405eaee74e4c15b400) 说即使报错也受到了微信支付的成功通知，又看到segmentfault里的[一个帖子](https://segmentfault.com/q/1010000014709128) 说**沙箱就是这样。。**

我真是艹了

### 接受回调

现有系统的Spring Security有点难整，调完之后发现会少几个字段，字符串处理到整数的时候要做处理。。

这块没啥好说的，记得做幂等性，然后校验支付回调金额和业务订单金额是否一致就行

2019-5-27更新
该死的微信SDK，判断支付结果通知中的sign是否有效的方法`isPayResultNotifySignatureValid()`里，默认没有传入签名类型的时候，选的是MD5

然后支付回调长这样（去掉了CDATA）：
```xml
<xml>
<appid>wxd50ee6fba4d33d87></appid>
<bank_type>PSBC_DEBIT></bank_type>
<cash_fee>2></cash_fee>
<fee_type>CNY></fee_type>
<is_subscribe>N></is_subscribe>
<mch_id>1533406601></mch_id>
<nonce_str>e67NXtscpEEgEvw2JPyU788rJzPszysT></nonce_str>
<openid>oou9Z5PDpeZJIECERxZzfqvx_Nuw></openid>
<out_trade_no>XDD1905210007-2></out_trade_no>
<result_code>SUCCESS></result_code>
<return_code>SUCCESS></return_code>
<sign>795821E960EE6F142C4508DC689C40ACDD02F1CCB40BE57993F821FE6896F209></sign>
<time_end>20190527143910></time_end>
<total_fee>2</total_fee>
<trade_type>JSAPI></trade_type>
<transaction_id>4200000311201905278323267941></transaction_id>
</xml>
```
明眼人都看得出sign绝对不是MD5，而且也真就不给sign_type……
必须得改SDK，把默认的sign_type改成HMAC（线上默认是HMAC）

然后是支付回调里没有trade_state，只有result_code，因为只推送成功结果，这点要和主动拉取支付结果做区分。

### 退款回调

发起退款的流程和发起支付类似，略过不表

退款回调没有sign字段，而且需要JDK装密钥长度无限[扩展包 ](https://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html) 。直接解密req_info字段即可，解密代码如下：

```java
    private String decrypt(String reqInfo) throws Exception {

//     （1）对加密串A做base64解码，得到加密串B
        byte[] encryptB = Base64.getDecoder().decode(reqInfo);
//     （2）对商户key做md5，得到32位小写key* ( key设置路径：微信商户平台(pay.weixin.qq.com)-->账户设置-->API安全-->密钥设置 )
        StringBuilder hexString = new StringBuilder();
        MessageDigest md = MessageDigest.getInstance("MD5");
        md.update(wscWxConfig.getKey().getBytes());
        byte[] hash = md.digest();
        for (byte b : hash) {
            if ((0xff & b) < 0x10) {
                hexString.append("0").append(Integer.toHexString((0xFF & b)));
            } else {
                hexString.append(Integer.toHexString(0xFF & b));
            }
        }
        String md5Key = hexString.toString();
//       (3）用key*对加密串B做AES-256-ECB解密（PKCS7Padding）
        Security.addProvider(new BouncyCastleProvider());
        Cipher cipher = Cipher.getInstance("AES/CBC/PKCS7Padding", "BC");
        Key sKeySpec = new SecretKeySpec(md5Key.getBytes(StandardCharsets.UTF_8), "AES");
        cipher.init(Cipher.DECRYPT_MODE, sKeySpec);
        byte[] result = cipher.doFinal(encryptB);
        return new String(result);
    }
```


### 2019-5-27 更新
什么毛病 沙箱服务器连不上 超时……

```
POST https://api.mch.weixin.qq.com/sandboxnew/pay/unifiedorder
Content-Type: text/xml
User-Agent: WXPaySDK/3.0.9 (amd64 Windows 8.1 6.3) Java/1.8.0_20 HttpClient/4.5.8 商户号

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<xml>
    <nonce_str>lqcB0bQXDivAXfYywcuiubWJLMbMOFNW</nonce_str>
    <openid>测试openId</openid>
    <sign>签名</sign>
    <fee_type>CNY</fee_type>
    <body>新天元 - 订单支付</body>
    <notify_url>http://hk.mothership.top/microManage/order/payResultNotify</notify_url>
    <mch_id>商户号</mch_id>
    <spbill_create_ip>127.0.0.1</spbill_create_ip>
    <out_trade_no>商户订单号</out_trade_no>
    <total_fee>101</total_fee>
    <appid>appId</appid>
    <trade_type>JSAPI</trade_type>
    <sign_type>MD5</sign_type>
</xml>

```

```xml
<xml>
  <return_code>FAIL></return_code>
  <retmsg><urlopen error timed out>></retmsg>
  <retcode>1></retcode>
</xml>
```

连不上沙箱干脆直接切正式吧，结果开始报`支付验证签名失败`……

查了一下，切正式的时候，prepay_id的签名方式需要和统一下单的一致，也就是必须改成"HMAC-SHA256"……




