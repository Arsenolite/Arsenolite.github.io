---
title: 2020-04-13-高阶面试题知识集合笔记
date: 2020-04-13 15:53:16
tags: ["Java","面经读后感"]
categories: ["2020-04"]
---

[TOC]

### 前言

嗯……写了快三年代码了，回望一下自己的博客，从当年命名规范都不清楚的小白，到现在。。熟悉了命名规范的小白（笑）

对自我的定义应该是：比较擅长在需求较明确的前提下，使用常用工具构建无需特别优化的Java Web后端程序的Java程序员，也对爬虫和Web后端性能优化比较感兴趣。

曾经对微服务、消息队列、缓存等知识是兴致缺缺，一方面没有好的资料，一方面两三年前不需要这些知识的岗位机会也有不少。

然而两年九个月过去了，对一些单机Web后端用到的技术，不敢说熟悉，日常理解是没多大问题了；恰好经树总推荐，拜读了DDIA，以及一些讲述大型网站的书籍，觉得是时候总结一些这方面的知识了。

虽然总觉得这些是90%的企业用不到的东西，但毕竟竞争日益激烈，再加上像是**`@Transaction` `@Cacheable`注解是基于AOP，AOP又是基于动态代理**，或者是**JVM采用分代垃圾收集，年轻代标记复制到老年代，老年代用CMS标记并发清除，或者用G1分区域标记整理**这些几年前学过的知识点，反复啃起来也没什么意思。。

---

### 消息队列

[RocketMQ开发指南](https://www.sxt.cn/ueditor/php/upload/file/20170901/1504248466272324.pdf)

---

#### 优缺点、如何选型

##### 优点

- 降低订阅消息与否的开发成本

- 异步化逻辑，提高性能

##### 缺点

- 降低可用性，一致性，提高复杂度（处理MQ失效问题，做幂等设计）

##### 选型

###### 延迟

RabbitMQ微秒级延迟，RocketMQ、Kafka使用长轮询，毫秒级

###### 吞吐

ActiveMQ较弱，面向企业已有设施对接

RabbitMQ万级，RocketMQ、Kafka十万级

Kafka的TPS在64个Topic时可以保持13万，到了128个Topic就跌至0.85万，原因是每个Topic、每个分区都会对应一个物理文件

###### 可用性

RabbitMQ主从架构，RocketMQ、Kafka分布式架构

###### 功能

RocketMQ支持定时消息、事务消息，消息查询，按时间回溯，乱序消费，消费轨迹，消息过滤

---

#### 幂等性

##### 唯一约束

借助数据库唯一索引、Redis Key是否存在校验等

##### 插入或更新

借助数据库的INSERT OR UPDATE、Redis的Set操作等

##### 多版本控制

加入Version字段

##### 状态机控制

根据业务设计状态流转图，避免逆向流转

---

#### 可靠性

##### 发送端

同步发送+重试机制+多个master节点

flushDiskType: SYNC_FLUSH

brokerRole: SYNC_MASTER

RocketMQ官方建议配置同步复制+异步刷盘，除非主从全部在异步刷盘完成前掉电才会丢失。

由于消费位点和消息不同时落盘，会导致重复消费，业务自行做好幂等性。

##### 接收端

RocketMQ Consumer 先 pull 消息到本地，消费完成后，才向服务器返回 ack，如果没有消费一定不会发送ack 消息， 所以 RocketMQ 可以很好的支持**At least Once**。

---

#### 可用性

##### Kafka

借用ZK实现Master选举

##### RocketMQ

NameServer实现Topic/Queue的路由信息，是负载均衡思想

RocketMQ在4.5后加入Dledger机制，基于Raft协议实现，可以在一分钟内选举Master Broker

---

#### 失效和积压问题

##### 失效问题

Broker会每天凌晨4点删除72小时前的数据，系统维护后手动写代码重新导入消息队列

##### 积压问题-紧急扩容

由于堆积的topic里面message queue数量固定，即使增加consumer的数量，它也不能分配到message queue。

这时我们可以写一个分发程序做一个临时topic队列扩充，来提高消费者能力。

程序从旧的topic中读取到新的topic，只是新的topic的queue可以指定多一点(理论上可以无限扩充，正常1000以内)，临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。

---

#### 顺序性

"恰好不解决它"

分布式系统下，时间意义不大，所谓顺序指的是因果顺序。

提供`MessageQueueSelector`，由用户实现算法， 保证同一个业务意义的消息进入同一个内存队列

---

#### 自己设计

##### 弹性

Topic分片存储在多个Broker中

##### 可靠性

提供同步刷盘特性

提供同步多写特性

##### 可用性

支持重新选举Master Broker

利用操作系统的页缓存实现异步刷盘

将同一个Broker所有的Topic消息实体放到一个物理文件

物理文件定长切分，使用FileChannel直接映射到内存

---

### 搜索引擎

ES分布式架构

https://zhuanlan.zhihu.com/p/33375126

https://juejin.im/entry/5c46d7c2e51d4551df6f2338

---

### 共识算法理论

---

### 分布式事务实践

---

借鉴蚂蚁金服分布式事务中间件 https://github.com/seata/seata

XA采用2PC模式，实际微服务实践中不用，因为不允许跨服务访问数据库



#### SAGA模式

基于状态机引擎，一致性弱，适用于事务参与者无法接入TCC改造的过程

可能会出现脏写，但是会尽可能保证最终一致性

https://www.sofastack.tech/blog/sofa-channel-10-retrospect/

---

#### RocketMQ事务消息

3.2.6阉割回查，4.3.0重新加入

1. 发送者发半事务消息给消息队列

2. 发送者执行事务

3. 发送者提交二次确认消息/消息队列回查发送者，确认提交/回滚

4. 消息队列负责不断重试投递给订阅者
5. 订阅者失败，则报警人工处理

---

#### AT模式

无侵入，二阶段回滚出现脏写需要人工介入

步骤：

- 框架拦截SQL，找到要更新的数据，在执行前后保存快照，再获取行锁

- 提交：删除快照和行锁
- 回滚：对比**当前数据**和**执行后快照**，一致则还原，不一致则转人工

---

#### TCC模式：

个人理解和2PC实际上是一回事，只不过2PC直接操作数据库事务，而TCC把这一概念放到了业务层，并且不需要持久层实际支持XA。

相比AT侵入性高，但是没有全局行锁，性能高

需要改造业务，业务分为try confirm和cancel步骤，try预留资源，confirm实际执行，cancel释放资源。

- 幂等性：需要保证三个步骤**幂等**。

- 并发控制：try预留的资源必须与事务ID关联，不同事务不能预留同一资源。

- 支持空回滚：需要在try业务未达时，就能处理cancel业务。

- 防悬挂：需要在cancel业务处理完后，能拒绝try业务。

整个事务所有方法每一步执行落地数据库，这样每个事务可查。

优化：confirm/cancel操作可以异步执行，事务记录可以记录在发起者业务数据库。

---

### 分布式事务理论

---

#### 2PC

第一阶段：协调者要求所有参与者作出修改，并记录修改的内容，并返回修改是否成功的消息。

第二阶段：协调者要求**一次**所有参与者正式提交，释放用到的资源（允许其他人继续修改），并发回确认消息。

- 有参与者提交失败则协调者指挥所有参与者回滚修改

- 有参与者在第一阶段没有响应，则超时后 协调者指挥所有参与者回滚修改

---

缺点也很明显：

- 单点故障：协调者中途失去响应，即使重新选举协调者，所有参与者之前锁定的资源也无法被释放

而且要求提交的请求只发送一次，会导致如下问题：

- 数据不一致：协调者发送的部分提交消息丢失，则有一部分参与者没有提交
- 特殊情况：协调者发送一条提交消息后掉线，接受到该消息的参与者也失去响应，则重新选举的协调者无法判断事务是否提交。

#### 2PC优化



---

#### Paxos

###### 简化场景：参与者只有一个

- 想法1（加锁）：所有客户端请求对参与者加锁，并发修改参与者

问题：客户端获取锁后失去响应，则其余客户端不再可以修改参与者

- 想法2（抢占修改权）：参与者可以废除客户端获取的“锁”，我们将这种锁称为“票”

客户端请求票时带上编号，参与者只接受票号大的修改；

但一旦修改完成后，参与者保证后续客户端即使票号更大，也要认同票号小的修改。

---

###### 再引入多个参与者

参与者少数服从多数，一旦多数参与者接受了某次修改，则其余参与者必须接受。

- 客户端使用一个票号，尝试抢占所有参与者的访问权
- 参与者会返回当前自身记录最大的票号，以及该票号对应的修改请求
- 如果客户端票号 比最大票号小，客户端**需要转而使其余参与者接受这个更大票号的修改请求**，以尽快通过**其他客户端的**修改请求
- 如果半数以上的参与者认为客户端使用的票号是最大的，则访问权获取成功，提出自己的修改请求

---

### 缓存
https://doocs.github.io/advanced-java/#/./docs/high-concurrency/why-cache
#### Redis线程模型

#### Redis数据类型

#### Redis性能，生产部署

#### Redis哨兵高可用

#### Redis穿透、雪崩、击穿

#### 数据库一致性

#### Redis锁和事务

---

### 微服务实践

#### 服务治理实践

#### 微服务框架使用

#### 微服务拆分实践

### 领域驱动设计

https://tech.meituan.com/2017/12/22/ddd-in-practice.html